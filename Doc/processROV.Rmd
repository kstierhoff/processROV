---
title: "processROV"
author: "Kevin L. Stierhoff"
date: "2/6/2020"
output: html_document
---

```{r setup, include=FALSE}
# Install and load pacman (library management package)
if (!require("pacman")) install.packages("pacman")

# Install and load required packages from CRAN ---------------------------------
pacman::p_load(tidyverse,lubridate,here,RODBC,forecast,cowplot,exifr,sf,fs)

# Install and load required packages from Github -------------------------------
# surveyR
pacman::p_load_gh("kstierhoff/surveyR")

# Set default ggplot2 theme
theme_set(theme_bw())
```

# Load user settings

User-defined settings control various processing steps and outputs.

```{r user-settings}
copy.files        <- F # Copy files from root directories
process.files     <- T # Process files
process.files.all <- T # Process all files, not only new ones
```

# Load project settings

Load the project-specific settings. The appropriate file is determined by the name of the directory containing the Rstudio project.  
```{r project-settings}
# Get project name from directory
prj.name <- last(unlist(str_split(here(),"/")))

# Get all settings files
settings.files <- dir(here("Doc/settings"))

# Source survey settings file
prj.settings <- settings.files[str_detect(settings.files, paste0("settings_", prj.name, ".R"))]
source(here("Doc/settings", prj.settings))
```

# Get database values

Query the database tables to determine the next index for each table, which is the "seed" value for new indices.

```{r}
# Query starting IDs for all database tables ####
channel <- odbcConnectAccess2007(db.dir)
nav.seed    <- as.numeric(sqlQuery(channel, "SELECT max(dbo_tbl_NAV.nav_id) AS nav_seed
                                   FROM dbo_tbl_NAV;")[1] + 1)
event.seed  <- as.numeric(sqlQuery(channel, "SELECT max(dbo_tbl_EVENTS.event_id) AS event_seed
                                   FROM dbo_tbl_EVENTS;")[1] + 1)
photo.seed  <- as.numeric(sqlQuery(channel, "SELECT max(dbo_tbl_PHOTO_INFO.photo_id) AS photo_seed
                                   FROM dbo_tbl_PHOTO_INFO;")[1] + 1)
ctd.seed    <- as.numeric(sqlQuery(channel, "SELECT max(dbo_tbl_CTD_CASTS.ctd_id) AS ctd_seed
                                   FROM dbo_tbl_CTD_CASTS;")[1] + 1)
close(channel)
```

# Get directories

```{r}
# Process NAV date from DAT files ####
if (.Platform$OS.type == "unix") { 
  # if working on a Mac
  dat.root 	<- "/Users/kevinstierhoff/NAVDATA" 	# This is the WinFrog project directory
  photo.root 	<- "/Users/kevinstierhoff/PHOTOS" # This is the photo directory
} else { 
  # if working on a Windows PC
  dat.root 	<- "C:/NAVDATA" # This is the WinFrog project directory
  photo.root 	<- "C:/PHOTOS"#  This is the photo directory
}

# Get a list of WinFrog project directories that contain NAV data
d <- sort(dir(dat.root, recursive = F, pattern = "\\d{2}-\\d{3}\\w", full.names = T))
p <- sort(dir(photo.root, recursive = F, pattern = "\\d{2}-\\d{3}\\w", full.names = T))

# dir.list <- d[which(d == start.dir):which(d == end.dir)]
dir.list   <- d[grep(dir.start, d):grep(dir.end, d)]
photo.list <- p[grep(dir.start, p):grep(dir.end, p)] 
```

# Copy files

Copy WinFrog navigation data and photos to a local directory for processing, leaving the original files in place.

```{r copy-files}
# Create file directories
dir_create(str_replace(dir.list, dat.root, here("Data/NAVDATA")))
dir_create(str_replace(photo.list, photo.root, here("Data/PHOTOS")))

if (copy.files) {
  # Copy WinFrog files
  dir_copy(dir.list, str_replace(dir.list, dat.root, here("Data/NAVDATA")),
           overwrite = TRUE)
  # Copy photos
  dir_copy(photo.list, str_replace(photo.list, photo.root, here("Data/PHOTOS")),
           overwrite = TRUE)
}
```

# Process nav files

Extract data from WinFrog navigation files for each transect. Optionally, to speed processing, only newly added files may be processed (`process.all` = `TRUE`).

```{r process-nav}
if (process.files) {
  # List local DAT directories
  dat.dirs <- dir_ls(here("Data/NAVDATA"))
  
  if (process.files.all) {
    # Create dataframe for nav data
    DAT 	 <- data.frame()
    
  } else {
    # Load already processed DAT file directories 
    if (file.exists(here("Output/processed_dat.rds"))) {
      readRDS(here("Output/processed_dat.rds"))
    }
    
    # Load already processed nav data
    readRDS(here("Data/NAVDATA/DAT.rds"))
  }  
  
  # Process DAT files
  if (!process.files.all) {
    # Get unprocessed directories
    dat.dirs <- dat.dirs[!dat.dirs %in% processed.dat]
    
    if (file.exists(here("Data/NAVDATA/DAT.rds"))) {
      # Load already processed vessel NASC data
      DAT <- readRDS(here("Data/NAVDATA/DAT.rds"))
    } else {
      # Create new data frame
      DAT <- tibble()  
    }
    
  } else {
    # Create new data frame
    DAT <- tibble() 
    
  }
  
  # Process remaining directories
  for (i in dat.dirs) {  
    # extract dive name from directory path
    dive.name <- 	str_extract(i,"\\d{2}-\\d{3}\\w")
    
    # List DAT files in directory
    dat.files <- dir_ls(i, regexp = "\\d{2}-\\d{3}\\w{1}(\\(\\d{3}-\\d{6}\\))?.DAT")
    
    # Create temporary dataframe for dive data
    DAT.tmp <- tibble()
    
    for (ii in dat.files) {
      # Read DAT file and append to previous
      dat <- read_csv(ii, col_names = F)
      DAT.tmp <- bind_rows(DAT.tmp, dat)
    }
    
    # Subset columns
    DAT.tmp <- select(DAT.tmp , c(1:47,65))
    
    # Add variable names to data frame
    names(DAT.tmp) <- c("oid","blank","date_time","lat_r","long_r","depth","northing_r","easting_r",
                        "blank","blank","blank","heading_r","cmg_r","speed_r","blank","blank","blank","blank",
                        "blank","blank","blank","blank","pitch","roll","temperature","conductivity",
                        "pressure","salinity","sound_vel","oxygen_conc","oxygen_sat","altitude",
                        "blank","blank","lat_s","long_s","blank","northing_s","easting_s","blank",
                        "blank","blank","heading_s","cmg_s","speed_s","blank","blank","blank")
    
    # Remove variables with no data
    DAT.tmp <- DAT.tmp[ , names(DAT.tmp) != "blank"]
    
    DAT.tmp <- DAT.tmp %>% 
      mutate(nav_id    = seq(nav.seed, nav.seed + n() - 1),
             object_id = oid + 1,
             dive_name = as.factor(dive.name),
             date_time = mdy_hms(date_time),
             lat_r     = winfrog2dd(lat_r),
             long_r    = winfrog2dd(long_r),
             lat_s     = winfrog2dd(lat_s),
             long_s    = winfrog2dd(long_s),
             time.int  = c(as.numeric(date_time[2:n()] - date_time[1:n() - 1]), 0),
             disp_s    = speed_s * 0.514444444 * time.int,
             disp_r    = speed_r * 0.514444444 * time.int,
             good      = 1)
    
    # Add DVL pitch/roll to position sensor to get the actual pitch/roll of the camera ####
    # Get directory of WinFrog RAW files to read
    raw.files <- dir_ls(i, regexp = "*.RAW")
    
    # Create tibble for raw data
    pr.data <- data.frame()
    
    for (k in raw.files) {
      pr.temp <- readLines(k)
      # Extract only PASHR sentences
      pr.temp <- pr.temp[grep("413-004-W,DVL [on HDHV]*", pr.temp)]
      # Split strings on commas
      pr.temp <- str_split(pr.temp, ",")
      # Convert list to data frame
      pr.temp <- do.call(rbind.data.frame, pr.temp)
      # Subset only columns with DVL data
      pr.temp <- pr.temp[ , 1:5]
      # Add names to data frame
      names(pr.temp) <- c("code","name","time","pitch","roll")
      # Convert numeric values from factor
      pr.temp <- mutate_at(pr.temp, c("time","pitch","roll"), ~as.numeric(as.character(.))) 
      # Convert time to datetime
      t.seed <- ymd_hms('1970-01-01 00:00:00')
      pr.temp <- mutate(pr.temp, date_time = t.seed + time)
      # Combine data frames
      pr.data <- bind_rows(pr.data, distinct(pr.temp))
    }
    
    # Match pitch and roll data to nav 
    pid <- numeric()
    pid.lag <- numeric()
    
    # Add DVL pitch to the pitch measured by the tilt tray position sensor
    if (nrow(pr.data) != nrow(DAT.tmp)) {
      # If RAW data are logged 'Continuously'
      for (jj in 1:nrow(DAT.tmp)) {
        # Calculate the time difference between jth video obs and each nav record
        time.diff	  <- abs(difftime(DAT.tmp$date_time[jj], pr.data$date_time, units = "secs"))
        # Get min index for merging later
        pid <- c(pid, which.min(time.diff))
        # Get time lag
        pid.lag <- c(pid.lag, as.numeric(time.diff[which.min(time.diff)]))
      }
      
      DAT.tmp$pitch <- DAT.tmp$pitch + round(pr.data$pitch[pid])
    } else { 
      # If RAW data are logged 'With Events'
      DAT.tmp$pitch <- DAT.tmp$pitch + round(pr.data$pitch)
    }
    
    # Write DVL pitch/roll data to CSV
    write_csv(pr.data, file.path(i, paste(dive.name, "PitchRollData.txt", sep = "_")),
              na = "-999")
    
    # Process CTD data
    if (!ctd.on) {  
      # If CTD not present, make data -999
      DAT.tmp <- DAT.tmp %>% 
        mutate(
          sal           = -999,
          conductivity  = -999,
          oxygen_conc   = -999,
          oxygen_sat    = -999,
          depth_p_r     = depth,
          pressure      = -999,
          sound_vel     = -999,  
          depth_msw_r   = depth)
    } else {
      # Else, process CTD data and calculate oxygen saturation
      # Calculate depth from pressure in SEAWATER (factors-in gravity and latitude)
      DAT.tmp <- DAT.tmp %>% 
        mutate(depth      = calc_depth(lat_s, pressure),
               depth_msw  = depth - altitude,
               oxygen_sat = calc_sat(salinity, temperature, oxygen_conc))
    }
    
    # Smooth ROV roll, pitch and altitude for width/area calculations
    # Replace NA values with raw (unsmoothed) data
    # Set bad (negative) altitude data to NA
    DAT.tmp$altitude[which(DAT.tmp$altitude < 0)] <- NA
    
    # If altitude data is present (not all values > 0)
    if (length(which(is.na(DAT.tmp$altitude) == F)) > 0) {
      # use linear interpolation to replace NAs
      DAT.tmp$altitude <- as.numeric(na.interp(DAT.tmp$altitude))
      # smooth altitude data
      DAT.tmp$altitude_sm <- as.numeric(ma(DAT.tmp$altitude, order = nav.smoother))
      # replace NA data with non-smoothed data
      isna <- which(is.na(DAT.tmp$altitude_sm) == T)
      DAT.tmp$altitude_sm[isna] <- DAT.tmp$altitude[isna] 
    } else {
      DAT.tmp$altitude_sm <- as.numeric(NA) 
    }
    
    # Smooth pitch data --------------------
    # Set negative (bad) altitude data to NA
    DAT.tmp$pitch[which(DAT.tmp$pitch >= 0)] <- NA
    
    # Use linear interpolation to replace NAs
    DAT.tmp$pitch    <- as.numeric(na.interp(DAT.tmp$pitch))
    DAT.tmp$pitch_sm <- as.numeric(ma(DAT.tmp$pitch,order = nav.smoother))
    
    # Replace NAs with non-smoothed data
    isna <- which(is.na(DAT.tmp$pitch_sm) == T)
    DAT.tmp$pitch_sm[isna] <- DAT.tmp$pitch[isna]
    DAT.tmp$pitch[which(DAT.tmp$pitch > 0)] <- NA
    
    # Smooth roll data ---------------------
    DAT.tmp$roll_sm <- as.numeric(ma(DAT.tmp$roll,order = nav.smoother))
    
    # Replace NAs with non-smoothed data
    isna <- which(is.na(DAT.tmp$roll_sm) == T)
    DAT.tmp$roll_sm[isna] <- DAT.tmp$roll[isna]
    
    # Calculate width and area ####
    # Uses the method described in Stierhoff et al. (in review) and calc_width function in surveyR package
    width.df <- calc_width(DAT.tmp$pitch_sm, DAT.tmp$altitude_sm, ROV = ROV) 
    
    DAT.tmp <- bind_cols(DAT.tmp, width.df) %>% 
      select(nav_id, object_id, dive_name, date_time, 
             lat_s, long_s, northing_s,easting_s,
             heading_s, cmg_s, speed_s, disp_s,
             lat_r, long_r, depth, northing_r, easting_r,
             heading_r,cmg_r,speed_r, pitch, roll,
             temperature, conductivity,pressure, salinity, 
             sound_vel, oxygen_conc, oxygen_sat,
             altitude, disp_r, good)
    
    # Write DAT data frame to CSV file for import into the database
    DAT.write <- DAT.tmp %>% 
      mutate(date_time = format(date_time, format = "%m/%d/%Y %H:%M:%S"))
    
    write_csv(DAT.write, file.path(i, paste(dive.name, "NavData.txt", sep = "_")), 
              na = "-999")
    
    # Add results to DAT.temp
    DAT <- rbind(DAT, DAT.write)
    
    # Plot CTD data -------------------------------
    ctd.gg <- DAT.tmp %>% 
      select(date_time, depth, depth_msw, salinity, conductivity, temperature, pressure,
             sound_vel, oxygen_conc, oxygen_sat) %>% 
      gather(variable, value, -date_time) 
    
    ctd.p 	<- ggplot(ctd.gg, aes(x = date_time, y = value, group = variable)) + 
      geom_line(colour = "blue") + scale_x_datetime() + 
      facet_wrap(~variable, scales = "free_y") + 
      labs(title = paste("CTD Data from transect ",dive.name,"\n",sep = "")) + 
      xlab("\nTime of Day (GMT)") + ylab("Sensor Value\n") +
      theme_bw() +
      theme(strip.text.x = element_text(size = 12, face = "bold"),
            strip.background = element_rect(fill = "white"),
            panel.spacing = unit(1, "lines"))
    
    # Save CTD plot
    ggsave(ctd.p, filename = here("Figs", paste(dive.name,"PhysData.png", sep = "_")), 
           height = 9.8, width = 13.3, units = "in")
    
    ggsave(ctd.p, filename = file.path(i, paste(dive.name,"PhysData.png", sep = "_")), 
           height = 9.8, width = 13.3, units = "in")
    
    # Plot results from center width and area calculations ----------------------
    # Plot pitch data
    p.gg <- DAT.tmp %>% 
      select(date_time, pitch, pitch_sm) %>% 
      gather(variable, value, -date_time)
    
    p.p	<- ggplot(p.gg, aes(x = date_time, y = value, colour = variable)) + 
      geom_line() +
      labs(title = paste("ROV data from ", dive.name,"\n", sep = "")) +
      xlab("") + ylab("Pitch (degrees)\n") + 
      scale_x_datetime() + 
      scale_colour_manual("Pitch", values = c("black","green"))
    
    # plot roll data
    r.gg <- DAT.tmp %>% 
      select(date_time, roll, roll_sm) %>% 
      gather(variable, value, -date_time)
    
    r.p	<- ggplot(r.gg, aes(x = date_time, y = value, colour = variable)) + 
      geom_line() + 
      xlab("") + ylab("Roll (degrees)\n") + 
      scale_x_datetime() + 
      scale_colour_manual("Roll",values = c("black","blue"))
    
    # plot altitude data
    a.gg <- DAT.tmp %>% 
      select(date_time, altitude, altitude_sm) %>% 
      gather(variable, value, -date_time)
    
    if (length(which(is.na(a.gg$value) == FALSE)) > 0) {
      a.p	<- ggplot(a.gg, aes(x = date_time, y = value, colour = variable)) + 
        geom_line() + 
        xlab("") + ylab("Altitude (meters)\n") + 
        scale_x_datetime() + 
        scale_colour_manual("Altitude", values = c("black","red","blue"))
    }
    
    # plot of ROV depth and altitude data
    z.gg <- DAT.tmp %>% 
      select(date_time, depth, depth_msw) %>% 
      gather(variable, value, -date_time)
    
    z.p <- ggplot(z.gg, aes(x = date_time, y = value, colour = variable)) + 
      geom_line() + 
      scale_colour_manual("Depth", values = c("green", "black")) + 
      xlab("\nTime of Day") + ylab("Depth (m)\n") +	
      scale_x_datetime()
    
    # Save the plot grid
    if (length(which(is.na(a.gg$value) == FALSE)) > 0) {
      nav.grid <- plot_grid(p.p, r.p, a.p, z.p, nrow = 4, align = "v")
      
      save_plot(file.path(i, paste(dive.name, "NavData.png", sep = "_")), 
                nav.grid, ncol = 1, nrow = 4, base_aspect_ratio = 4)
      
      save_plot(here("Figs", paste(dive.name, "NavData.png", sep = "_")), 
                nav.grid, ncol = 1, nrow = 4, base_aspect_ratio = 4)
      
    } else {
      nav.grid <- plot_grid(p.p, r.p, z.p, nrow = 3, align = "v")
      
      save_plot(file.path(i, paste(dive.name, "NavData.png", sep = "_")), 
                nav.grid, ncol = 1, nrow = 3, base_aspect_ratio = 4)
      
      save_plot(here("Figs", paste(dive.name, "NavData.png", sep = "_")), 
                nav.grid, ncol = 1, nrow = 3, base_aspect_ratio = 4)
    }
    
    # Plot camera data ---------------------------------------------------
    # If camera altitude data is not all NA
    if (length(which(is.na(width.df$camera_altitude) == FALSE)) > 0) {
      width.df$date_time <- DAT.tmp$date_time
      
      w.gg <-  gather(width.df, variable, value, -date_time)
      
      w.p <- ggplot(w.gg, aes(x = date_time, y = value, colour = variable)) + 
        geom_line() + 
        scale_colour_manual("Variable", values = c("green","black","blue")) + 
        xlab("\nDate/time") + ylab("Variable (m)\n") +	
        scale_x_datetime() +	
        labs(title = paste0("Camera data from ", dive.name, "\n"))
      
      ggsave(w.p, filename = file.path(i, paste(dive.name, "CameraData.png", sep = "_")),
             height = 5, width = 10, units = "in")
      
      ggsave(w.p, filename = here("Figs", paste(dive.name, "CameraData.png", sep = "_")),
             height = 5, width = 10, units = "in")
    }
    
    
  }
  
  # Create a vector of processed directories
  processed.dat <- unique(file.path(dat.root, DAT.temp$dive_name))
}
```

# Process photos

Extract metadata (exif information) from still photos for each transect. Optionally, to speed processing, only newly added files may be processed (`process.all` = `TRUE`).

```{r process-photos}
if (process.files) {
  if (process.files.all) {
    PHOTO.temp <- data.frame()
    LOG.temp 	 <- data.frame()
    CTD.temp 	 <- data.frame()
  } else {
    
  }  
}
```

# Plot results

```{r plot-results}

```


# Export results

```{r export-results}

```

